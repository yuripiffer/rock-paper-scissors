// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package model

import (
	"sync"
)

// Ensure, that InputWatcherMock does implement InputWatcher.
// If this is not the case, regenerate this file with moq.
var _ InputWatcher = &InputWatcherMock{}

// InputWatcherMock is a mock implementation of InputWatcher.
//
//	func TestSomethingThatUsesInputWatcher(t *testing.T) {
//
//		// make and configure a mocked InputWatcher
//		mockedInputWatcher := &InputWatcherMock{
//			NumberFunc: func(message string) (int, error) {
//				panic("mock out the Number method")
//			},
//			TextFunc: func(message string) (string, error) {
//				panic("mock out the Text method")
//			},
//		}
//
//		// use mockedInputWatcher in code that requires InputWatcher
//		// and then make assertions.
//
//	}
type InputWatcherMock struct {
	// NumberFunc mocks the Number method.
	NumberFunc func(message string) (int, error)

	// TextFunc mocks the Text method.
	TextFunc func(message string) (string, error)

	// calls tracks calls to the methods.
	calls struct {
		// Number holds details about calls to the Number method.
		Number []struct {
			// Message is the message argument value.
			Message string
		}
		// Text holds details about calls to the Text method.
		Text []struct {
			// Message is the message argument value.
			Message string
		}
	}
	lockNumber sync.RWMutex
	lockText   sync.RWMutex
}

// Number calls NumberFunc.
func (mock *InputWatcherMock) Number(message string) (int, error) {
	callInfo := struct {
		Message string
	}{
		Message: message,
	}
	mock.lockNumber.Lock()
	mock.calls.Number = append(mock.calls.Number, callInfo)
	mock.lockNumber.Unlock()
	if mock.NumberFunc == nil {
		var (
			nOut   int
			errOut error
		)
		return nOut, errOut
	}
	return mock.NumberFunc(message)
}

// NumberCalls gets all the calls that were made to Number.
// Check the length with:
//
//	len(mockedInputWatcher.NumberCalls())
func (mock *InputWatcherMock) NumberCalls() []struct {
	Message string
} {
	var calls []struct {
		Message string
	}
	mock.lockNumber.RLock()
	calls = mock.calls.Number
	mock.lockNumber.RUnlock()
	return calls
}

// Text calls TextFunc.
func (mock *InputWatcherMock) Text(message string) (string, error) {
	callInfo := struct {
		Message string
	}{
		Message: message,
	}
	mock.lockText.Lock()
	mock.calls.Text = append(mock.calls.Text, callInfo)
	mock.lockText.Unlock()
	if mock.TextFunc == nil {
		var (
			sOut   string
			errOut error
		)
		return sOut, errOut
	}
	return mock.TextFunc(message)
}

// TextCalls gets all the calls that were made to Text.
// Check the length with:
//
//	len(mockedInputWatcher.TextCalls())
func (mock *InputWatcherMock) TextCalls() []struct {
	Message string
} {
	var calls []struct {
		Message string
	}
	mock.lockText.RLock()
	calls = mock.calls.Text
	mock.lockText.RUnlock()
	return calls
}
